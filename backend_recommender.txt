from app.models import db
from app.models.model import Course, Category, Topic, Instructor
import os, math
try:
    import google.generativeai as genai  # type: ignore
except Exception:  # pragma: no cover
    genai = None

_GEMINI_EMBED_MODEL = "text-embedding-004"
_GEMINI_KEY = os.getenv("GEMINI_API_KEY") or os.getenv("GOOGLE_API_KEY") or os.getenv("GOOGLE_GEMINI_KEY")
_EMBED_CACHE = {}  # course_id -> list[float]
_QUERY_CACHE = {}  # query string -> list[float]
_GEMINI_READY = False

def _init_gemini():
    global _GEMINI_READY
    if _GEMINI_READY:
        return
    if genai and _GEMINI_KEY:
        try:
            genai.configure(api_key=_GEMINI_KEY)
            _GEMINI_READY = True
        except Exception:
            _GEMINI_READY = False

def _norm(s: str) -> str:
    return (s or '').strip().lower()


def _tokenize(s: str):
    s = _norm(s)
    for ch in ',./\\;:\"\'|()[]{}!@#$%^&*?-_+\n\r\t':
        s = s.replace(ch, ' ')
    return [w for w in s.split() if w]


def recommend_courses(level=None, major=None, topic=None, language=None, limit=6):
    """
    Heuristic recommender with simple relevance scoring:
    - Filter by level/category/topic when provided.
    - Score courses by keyword matches in title/description/categories/topics.
    - Ensure at least 3 results by relaxing filters if needed.
    """
    level = _norm(level) if level else ''
    major = _norm(major) if major else ''
    topic = _norm(topic) if topic else ''
    language = _norm(language) if language else ''

    def base_query():
        q = Course.query
        if language:
            q = q.filter(db.func.lower(Course.language) == language)
        if level:
            q = q.filter(db.func.lower(Course.level) == level)
        if major:
            q = q.join(Course.categories)
            q = q.filter(db.or_(db.func.lower(Category.name) == major, db.func.lower(Category.slug) == major))
        if topic:
            q = q.join(Course.topics)
            q = q.filter(db.or_(db.func.lower(Topic.name) == topic, db.func.lower(Topic.slug) == topic))
        return q.distinct()

    def to_dict(c: Course):
        instructor_name = None
        if c.instructor_id:
            ins = Instructor.query.get(c.instructor_id)
            if ins and getattr(ins, 'user', None):
                instructor_name = ins.user.full_name
        return {
            'id': c.id,
            'title': c.title,
            'description': c.description,
            'level': c.level,
            'price': float(c.price) if c.price is not None else 0,
            'currency': c.currency,
            'categories': [cat.name for cat in getattr(c, 'categories', []) if getattr(cat, 'name', None)],
            'topics': [t.name for t in getattr(c, 'topics', []) if getattr(t, 'name', None)],
            'instructorName': instructor_name,
        }

    def score_course(c: Course) -> float:
        title = _norm(getattr(c, 'title', ''))
        desc = _norm(getattr(c, 'description', ''))
        cat_names = ' '.join([_norm(getattr(cat, 'name', '')) for cat in getattr(c, 'categories', [])])
        top_names = ' '.join([_norm(getattr(t, 'name', '')) for t in getattr(c, 'topics', [])])
        text_blob = ' '.join([title, desc, cat_names, top_names])
        tokens = set(_tokenize(text_blob))
        score = 0.0
        # Keyword hits
        for kw in [major, topic]:
            if kw:
                if kw in tokens:
                    score += 3.0
                else:
                    # partial containment
                    if kw and kw in text_blob:
                        score += 1.5
        # Level bonus
        try:
            if level and _norm(getattr(c, 'level', '')) == level:
                score += 1.0
        except Exception:
            pass
        # Recentness bonus (optional via created_at)
        try:
            if getattr(c, 'created_at', None):
                score += 0.2
        except Exception:
            pass
        return score

    def apply_language_filter(query):
        if language:
            return query.filter(db.func.lower(Course.language) == language)
        return query

    # First pass with all filters
    q = base_query()
    courses = q.all()
    scored = sorted(courses, key=score_course, reverse=True)

    # Fallbacks to ensure at least 3
    if len(scored) < 3:
        # Relax topic filter but keep level and language
        q2 = apply_language_filter(Course.query)
        if level:
            q2 = q2.filter(db.func.lower(Course.level) == level)
        if major:
            q2 = q2.join(Course.categories).filter(db.or_(db.func.lower(Category.name) == major, db.func.lower(Category.slug) == major))
        extra = q2.distinct().all()
        scored = sorted(extra, key=score_course, reverse=True)
    if len(scored) < 3:
        # Relax level but keep major/topic and language
        q3 = apply_language_filter(Course.query)
        if major:
            q3 = q3.join(Course.categories).filter(db.or_(db.func.lower(Category.name) == major, db.func.lower(Category.slug) == major))
        if topic:
            q3 = q3.join(Course.topics).filter(db.or_(db.func.lower(Topic.name) == topic, db.func.lower(Topic.slug) == topic))
        scored = sorted(q3.distinct().all(), key=score_course, reverse=True)

    # Final slice
    result = [to_dict(c) for c in scored[:max(limit, 3)]]
    # If still less than 3, append more globally by relevance
    if len(result) < 3:
        rest = apply_language_filter(Course.query).order_by(Course.created_at.desc()).limit(10).all()
        rest_scored = sorted(rest, key=score_course, reverse=True)
        for c in rest_scored:
            if c.id not in {r['id'] for r in result}:
                result.append(to_dict(c))
                if len(result) >= 3:
                    break
    return result

# ===================== SEMANTIC GEMINI RECOMMENDER =====================

def _cosine(a, b):
    try:
        if not a or not b:
            return 0.0
        num = sum(x*y for x,y in zip(a,b))
        da = math.sqrt(sum(x*x for x in a))
        db = math.sqrt(sum(y*y for y in b))
        if da == 0 or db == 0:
            return 0.0
        return num / (da*db)
    except Exception:
        return 0.0

def _course_text(c: Course) -> str:
    cats = ' '.join([getattr(cat,'name','') for cat in getattr(c,'categories',[])])
    tops = ' '.join([getattr(t,'name','') for t in getattr(c,'topics',[])])
    return ' | '.join(filter(None,[getattr(c,'title',''), getattr(c,'description',''), cats, tops, getattr(c,'level','')]))[:1500]

def _embed_text(text: str):
    _init_gemini()
    if not _GEMINI_READY:
        return None
    text = (text or '').strip()
    if not text:
        return None
    try:
        emb = genai.embed_content(model=_GEMINI_EMBED_MODEL, content=text, task_type="retrieval_document")
        vec = emb.get('embedding') or emb.get('data', [{}])[0].get('embedding')
        return vec
    except Exception:
        return None

def _get_course_embedding(c: Course):
    cid = c.id
    if cid in _EMBED_CACHE:
        return _EMBED_CACHE[cid]
    vec = _embed_text(_course_text(c))
    if vec:
        _EMBED_CACHE[cid] = vec
    return vec

def _get_query_embedding(query: str):
    q = (query or '').strip()
    if not q:
        return None
    if q in _QUERY_CACHE:
        return _QUERY_CACHE[q]
    vec = _embed_text(q)
    if vec:
        _QUERY_CACHE[q] = vec
    return vec

def _to_dict(c: Course, semantic=False):
    instructor_name = None
    if c.instructor_id:
        ins = Instructor.query.get(c.instructor_id)
        if ins and getattr(ins,'user',None):
            instructor_name = ins.user.full_name
    return {
        'id': c.id,
        'title': c.title,
        'description': c.description,
        'level': c.level,
        'price': float(c.price) if c.price is not None else 0,
        'currency': c.currency,
        'categories': [cat.name for cat in getattr(c,'categories',[]) if getattr(cat,'name',None)],
        'topics': [t.name for t in getattr(c,'topics',[]) if getattr(t,'name',None)],
        'instructorName': instructor_name,
        '_semantic': semantic,
    }

def semantic_recommend(query: str, limit=6, level=None, major=None, topic=None):
    query = (query or '').strip()
    if not query:
        return []
    # Try semantic embedding; if fails fallback to keyword heuristic
    q_vec = _get_query_embedding(query)
    # Pre-filter by structured fields if provided to narrow set
    base = Course.query
    if level:
        base = base.filter(db.func.lower(Course.level) == _norm(level))
    if major:
        base = base.join(Course.categories).filter(db.or_(db.func.lower(Category.name) == _norm(major), db.func.lower(Category.slug) == _norm(major)))
    if topic:
        base = base.join(Course.topics).filter(db.or_(db.func.lower(Topic.name) == _norm(topic), db.func.lower(Topic.slug) == _norm(topic)))
    courses = base.distinct().all()
    # Fallback enlarge set if too small
    if len(courses) < 3:
        courses = Course.query.all()

    scored = []
    for c in courses:
        # keyword score reuse
        kw_score = 0.0
        blob = _norm(query)
        text_blob = _norm(_course_text(c))
        if blob:
            if blob in text_blob:
                kw_score += 2.0
            # split tokens
            for tk in set(_tokenize(blob)):
                if tk and tk in text_blob:
                    kw_score += 0.5
        if q_vec:
            c_vec = _get_course_embedding(c)
            sim = _cosine(q_vec, c_vec) if c_vec else 0.0
        else:
            sim = 0.0
        blend = sim * 0.6 + kw_score * 0.4
        scored.append((blend, sim, kw_score, c))

    scored.sort(key=lambda x: x[0], reverse=True)
    result = [_to_dict(c, semantic=True) for (blend, sim, kw, c) in scored[:limit]]
    if len(result) < max(3, limit):
        # complement with heuristic recommend
        extra = recommend_courses(level=level, major=major, topic=topic, limit=limit)
        seen = {r['id'] for r in result}
        for e in extra:
            if e['id'] not in seen:
                e['_semantic'] = False
                result.append(e)
            if len(result) >= limit:
                break
    return result

__all__ = [
    'recommend_courses',
    'semantic_recommend'
]
